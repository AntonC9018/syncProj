using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using System.Xml.Serialization;

/// <summary>
/// Custom class for mapping enumeration values to premake configuration tag.
/// </summary>
public class FunctionNameAttribute : Attribute
{
    /// <summary>
    /// function name itself.
    /// </summary>
    public String tag;

    /// <summary>
    /// function name attribute
    /// </summary>
    public FunctionNameAttribute(String s)
    {
        tag = s;
    }
}


/// <summary>
/// Specifies whether or not to use precompiled headers
/// </summary>
public enum EPrecompiledHeaderUse
{
    /// <summary>
    /// Create precompiled headers
    /// </summary>
    Create = 2,
    /// <summary>
    /// Use precompiled headers
    /// </summary>
    Use = 1,

    /// <summary>
    /// Default value (not initialized)
    /// </summary>
    NotUsing = 0 //enum default is 0.
}

/// <summary>
/// Specifies the level of warning to be generated by the compiler.
/// </summary>
public enum EWarningLevel
{
    /// <summary>
    /// Level 0 disables all warnings.
    /// </summary>
    TurnOffAllWarnings,
    /// <summary>
    /// Level 1 displays severe warnings. Level 1 is the default setting.
    /// </summary>
    Level1,
    /// <summary>
    /// Level 2 displays all level 1 warnings and warnings that are less severe than level 1.
    /// </summary>
    Level2,
    /// <summary>
    /// Level 3 displays all level 2 warnings and all other warnings that are recommended for production purposes.
    /// </summary>
    Level3,
    /// <summary>
    /// Level 4 displays all level 3 warnings and informational warnings. We recommend that you use this option only to provide lint-like warnings. 
    /// However, for a new project, it may be best to use /W4 in all compilations; this will ensure the fewest possible hard-to-find code defects.
    /// </summary>
    Level4,
    /// <summary>
    /// Displays all /W4 warnings and any other warnings that are not included in /W4—for example, warnings that are off by default.
    /// </summary>
    EnableAllWarnings
}

/// <summary>
/// Defines what needs to be done with given item. Not all project types support all enumerations - for example
/// packaging projects / C# projects does not support CustomBuild.
/// </summary>
public enum IncludeType
{
    /// <summary>
    /// Header file (.h)
    /// </summary>
    ClInclude,

    /// <summary>
    /// Any custom file with custom build step
    /// </summary>
    CustomBuild,

    /// <summary>
    /// Source codes (.cpp) files
    /// </summary>
    ClCompile,

    /// <summary>
    /// .def / .bat
    /// </summary>
    None,

    /// <summary>
    /// .txt files.
    /// </summary>
    Text,

    /// <summary>
    /// .rc / resource files.
    /// </summary>
    ResourceCompile,

    /// <summary>
    /// .ico files.
    /// </summary>
    Image,

    // Following enumerations are used in android packaging project (.androidproj)
    Content,
    AntBuildXml,
    AndroidManifest,
    AntProjectPropertiesFile,

    /// <summary>
    /// For Android package project: Reference to another project, which needs to be included into package.
    /// </summary>
    ProjectReference,

    /// <summary>
    /// Intentionally not valid value, so can be replaced with correct one. (Visual studio does not supports one)
    /// </summary>
    Invalid
}

/// <summary>
/// Defines debug information format.
/// </summary>
public enum EDebugInformationFormat
{
    /// <summary>
    /// Applicable for windows projects only
    /// </summary>
    EditAndContinue,

    /// <summary>
    /// Applicable for windows and android projects
    /// </summary>
    None,

    /// <summary>
    /// Applicable for windows projects only
    /// </summary>
    OldStyle,

    /// <summary>
    /// Applicable for windows projects only
    /// </summary>
    ProgramDatabase,
    
    /// <summary>
    /// Applicable for android projects only.
    /// </summary>
    LineNumber,

    /// <summary>
    /// Applicable for android projects only.
    /// </summary>
    FullDebug
}



/// <summary>
/// Configuration class which configures project as well as individual file entries.
/// </summary>
[DebuggerDisplay("Configuration( confName:'{confName}' )")]
public class FileConfigurationInfo
{
    /// <summary>
    /// For debugging purposes - specifies configuration name (Debug|Win32) with which given configuration is accosiated with.
    /// </summary>
    public String confName;
    //--------------------------------------------------------------------------------------------
    // Following fields are located under following XML nodes
    // ItemDefinitionGroup\
    //                     ClCompile
    //                     Link
    // ItemGroup\
    //                     ClCompile
    //--------------------------------------------------------------------------------------------
    
    /// <summary>
    /// Precompile header - use or create.
    /// </summary>
    public EPrecompiledHeaderUse PrecompiledHeader = EPrecompiledHeaderUse.NotUsing;

    /// <summary>
    /// Defines, ';' separated list.
    /// </summary>
    public String PreprocessorDefinitions = "";

    /// <summary>
    /// Additional Include Directories, ';' separated list.
    /// </summary>
    public String AdditionalIncludeDirectories = "";
    public String ShowIncludes;

    /// <summary>
    /// obj / lib files, ';' separated list.
    /// On windows platform can include also libraries, on android 'LibraryDependencies' specifies library files.
    /// </summary>
    public String AdditionalDependencies = "";

    /// <summary>
    /// Android specific: Additional libraries to link
    /// </summary>
    public String LibraryDependencies = "";

    /// <summary>
    /// Additional directory from where to search obj / lib files, ';' separated list.
    /// </summary>
    public String AdditionalLibraryDirectories = "";

    /// <summary>
    /// Output filename
    /// </summary>
    public String ObjectFileName;
    public String XMLDocumentationFileName;

    /// <summary>
    /// Precompiled header file
    /// </summary>
    public String PrecompiledHeaderFile = "stdafx.h";

    /// <summary>
    /// Optimization level
    /// </summary>
    public EOptimization Optimization = EOptimization.MaxSpeed;

    /// <summary>
    /// Allows the compiler to package individual functions in the form of packaged functions (COMDATs).
    /// </summary>
    public bool FunctionLevelLinking = false;

    /// <summary>
    /// Replaces some function calls with intrinsic or otherwise special forms of the function that help your application run faster.
    /// </summary>
    public bool IntrinsicFunctions = false;

    /// <summary>
    /// Some sort of linker optimization flag: COMDAT folding
    /// </summary>
    public bool EnableCOMDATFolding = false;

    /// <summary>
    /// Eliminates functions and data that are never referenced
    /// </summary>
    public bool OptimizeReferences = false;

    /// <summary>
    /// Format of debug information
    /// </summary>
    public EDebugInformationFormat DebugInformationFormat = EDebugInformationFormat.ProgramDatabase;

    /// <summary>
    /// Custom build step for includeType.CustomBuild specification.
    /// </summary>
    public CustomBuildRule customBuildRule;
}


/// <summary>
/// Information about that particular file.
/// </summary>
[DebuggerDisplay("{relativePath} ({includeType})")]
public class FileInfo
{
    /// <summary>
    /// Include type, same as specified in .vcxproj / .androidproj.
    /// </summary>
    public IncludeType includeType;

    /// <summary>
    /// Relative path to file (from project path perspective)
    /// </summary>
    public String relativePath;

    /// <summary>
    /// Android specific: when includeType == ProjectReference - specifies referenced project guid. Includes guid brackets - '{'/'}'
    /// </summary>
    public String Project;

    /// <summary>
    /// Per configuration specific file configuration.
    /// </summary>
    public List<FileConfigurationInfo> fileConfig = new List<FileConfigurationInfo>();
}

/// <summary>
/// Custom build tool properties.
/// </summary>
[DebuggerDisplay("Custom Build Tool '{Message}'")]
public class CustomBuildRule
{
    /// <summary>
    /// Visual studio: Command line
    /// </summary>
    public String Command = "";
    /// <summary>
    /// Visual studio: description. Use empty string to supress message printing.
    /// </summary>
    public String Message = "Performing Custom Build Tools";
    /// <summary>
    /// Visual studio: outputs
    /// </summary>
    public String Outputs = "";
    /// <summary>
    /// Visual studio: additional dependencies
    /// </summary>
    public String AdditionalInputs = "";

    /// <summary>
    /// Gets class instance as one xml string.
    /// </summary>
    public override string ToString()
    {
        XmlSerializer ser = new XmlSerializer(typeof(CustomBuildRule), typeof(CustomBuildRule).GetNestedTypes());
        using (var ms = new MemoryStream())
        {
            ser.Serialize(ms, this);
            return Encoding.UTF8.GetString(ms.ToArray());
        }
    }

    /// <summary>
    /// Decodes class from string
    /// </summary>
    /// <param name="inS">xml string to deserialize</param>
    /// <returns>CustomBuildRule class instance</returns>
    public static CustomBuildRule FromString(String inS)
    {
        XmlSerializer ser = new XmlSerializer(typeof(CustomBuildRule), typeof(CustomBuildRule).GetNestedTypes());

        using (TextReader reader = new StringReader(inS))
        {
            return (CustomBuildRule)ser.Deserialize(reader);
        }
    }
}

/// <summary>
/// Project type
/// </summary>
public enum EConfigurationType
{
    /// <summary>
    /// .exe
    /// </summary>
    [FunctionName("WindowedApp")]
    Application = 0,

    /// <summary>
    /// .dll
    /// </summary>
    [FunctionName("SharedLib")]
    DynamicLibrary
};

/// <summary>
/// Character set - unicode MBCS.
/// </summary>
public enum ECharacterSet
{ 
    /// <summary>
    /// Unicode
    /// </summary>
    [FunctionName("Unicode")]
    Unicode = 0,
    
    /// <summary>
    /// Ansi
    /// </summary>
    [FunctionName("MBCS")]
    MultiByte
}


[Description("")]   // Marker to switch Enum value / Description when parsing
public enum EWholeProgramOptimization
{
    /// <summary>
    /// Visual studio default.
    /// </summary>
    [Description("false")]
    NoWholeProgramOptimization = 0,

    [Description("true")]
    UseLinkTimeCodeGeneration,

    [Description("PGInstrument")]
    ProfileGuidedOptimization_Instrument,

    [Description("PGOptimize")]
    ProfileGuidedOptimization_Optimize,

    [Description("PGUpdate")]
    ProfileGuidedOptimization_Update
}


/// <summary>
/// Binary image format / target
/// </summary>
public enum ESubSystem
{
    /// <summary>
    /// Not specified
    /// </summary>
    NotSet,
    /// <summary>
    /// Windows application
    /// </summary>
    Windows,
    /// <summary>
    /// Console application
    /// </summary>
    Console,
    Native,
    EFI_Application,
    EFI_Boot_Service_Driver,
    EFI_ROM,
    EFI_Runtime,
    POSIX
}

/// <summary>
/// How to optimize code ?
/// </summary>
public enum EOptimization
{
    [FunctionName("custom")]
    Custom,
    
    /// <summary>
    /// No optimizations
    /// </summary>
    [FunctionName("off")]
    Disabled,

    /// <summary>
    /// Minimize Size
    /// </summary>
    [FunctionName("size")]
    MinSpace,

    /// <summary>
    /// Maximize Speed
    /// </summary>
    [FunctionName("speed")]
    MaxSpeed,

    /// <summary>
    /// Full Optimization
    /// </summary>
    [FunctionName("on")]
    Full
}

/// <summary>
/// Generate debug information
/// </summary>
[Description("")]   // Marker to switch Enum value / Description when parsing
public enum EGenerateDebugInformation
{
    /// <summary>
    /// No
    /// </summary>
    [Description("false"), FunctionName("off")]
    No = 0,

    /// <summary>
    /// Optimize for debugging
    /// </summary>
    [Description("true"), FunctionName("on")]
    OptimizeForDebugging,

    /// <summary>
    /// Use fast linking
    /// </summary>
    [Description("DebugFastLink"), FunctionName("fastlink")]
    OptimizeForFasterLinking
}

/// <summary>
/// Compile As option.
/// </summary>
public enum ECompileAs
{
    /// <summary>
    /// Compile as 'Default'
    /// </summary>
    [FunctionName("default")]
    Default,

    /// <summary>
    /// Compile as C++ Code (-x c++)
    /// </summary>
    [FunctionName("cpp")]
    CompileAsCpp,

    /// <summary>
    /// Compile as C Code (-x c)
    /// </summary>
    [FunctionName("c")]
    CompileAsC
}


/// <summary>
/// All values set by default are Visual Studio default.
/// </summary>
public class Configuration: FileConfigurationInfo
{
    /// <summary>
    /// Project type
    /// </summary>
    public EConfigurationType ConfigurationType = EConfigurationType.Application;

    /// <summary>
    /// Called when ConfigurationType has changed.
    /// </summary>
    public void ConfigurationTypeUpdated()
    {
        // ConfigurationType changes, maybe makes sense to check TargetExt later on ?
    } //ConfigurationTypeUpdated

    public bool UseDebugLibraries = false;

    /// <summary>
    /// Android api level, for example "android-22".
    /// By default "android-19" (KitKat 4.4 - 4.4.4, (android-19))
    /// </summary>
    public String AndroidAPILevel = "android-19";

    /// <summary>
    /// For example:
    ///     null - default
    ///     'Clang_3_8'     - Clang 3.8
    ///     'v140'          - for Visual Studio 2015.
    ///     'v120'          - for Visual Studio 2013.
    /// </summary>
    public String PlatformToolset;

    /// <summary>
    /// Queries default value for PlatformToolset.
    /// </summary>
    /// <param name="p">Project against which to query</param>
    /// <returns>Default value</returns>
    public String getPlatformToolsetDefault(Project p)
    {
        switch (p.Keyword)
        {
            case EKeyword.Android:
                return "Clang_3_8";
            default:
            case EKeyword.Win32Proj:
                return "v140";
        }
    }


    public ECharacterSet CharacterSet = ECharacterSet.Unicode;

    public bool LinkIncremental = true;
    public EWholeProgramOptimization WholeProgramOptimization;

    /// <summary>
    /// Output Directory. 
    ///     Visual studio default:  can be queried using getOutDirDefault()
    ///     premake default:        bin\$(Platform)\$(Configuration)\
    /// </summary>
    public String OutDir;

    /// <summary>
    /// Gets default value for OutDir field.
    /// </summary>
    /// <param name="p">Project against which to query</param>
    /// <returns>Default value</returns>
    public String getOutDirDefault( Project p )
    {
        switch (p.Keyword)
        {
            case EKeyword.Android:
                return @"$(SolutionDir)$(Platform)\$(Configuration)\";
            default:
            case EKeyword.Win32Proj:
                return "$(SolutionDir)$(Configuration)\\";
        }
    }

    /// <summary>
    /// Intermediate Directory.
    ///     Visual studio default:  $(Configuration)\
    ///     premake default:        obj\$(Platform)\$(Configuration)\
    /// </summary>
    public String IntDir;

    /// <summary>
    /// Gets intermediate directory default.
    /// </summary>
    /// <param name="p">project</param>
    /// <returns>Default value of IntDir</returns>
    public String getIntDirDefault(Project p)
    {
        switch (p.Keyword)
        {
            case EKeyword.Android:
                return @"$(Platform)\$(Configuration)\";
            default:
            case EKeyword.Win32Proj:
                return @"$(Configuration)\";
        }
    }

    /// <summary>
    /// Target Name.
    /// Visual studio default: $(ProjectName)
    /// </summary>
    public String TargetName;

    /// <summary>
    /// Gets default value for TargetName
    /// </summary>
    /// <param name="p">Project against which to query</param>
    /// <returns>Default value</returns>
    public String getTargetNameDefault(Project p)
    {
        switch (p.Keyword)
        {
            case EKeyword.Android:
                return "lib$(RootNamespace)";
            default:
            case EKeyword.Win32Proj:
                return "$(ProjectName)";
        }
    }

    /// <summary>
    /// Target Extension (.exe, .dll, ...).
    /// If set to default - must be null.
    /// </summary>
    public String TargetExt;

    /// <summary>
    /// Gets default value for target ext.
    /// </summary>
    /// <param name="p">Project against which to query</param>
    /// <returns>Default value</returns>
    public String getTargetExtDefault(Project p)
    {
        switch (p.Keyword)
        {
            case EKeyword.Android:
                return ".so";
            default:
            case EKeyword.Win32Proj:
                return ".dll";
        }
    }



    public EWarningLevel WarningLevel = EWarningLevel.Level1;

    /// <summary>
    /// Typically Windows or Console.
    /// </summary>
    public ESubSystem SubSystem;

    /// <summary>
    /// Visual studio defaults: OptimizeForDebugging for release, OptimizeForFasterLinking for debug.
    /// </summary>
    public EGenerateDebugInformation GenerateDebugInformation;

    /// <summary>
    /// Android specific.
    /// </summary>
    public String AndroidAppLibName;

    /// <summary>
    /// Android specific.
    /// </summary>
    public ECompileAs CompileAs;
}

/// <summary>
/// Tags platform
/// </summary>
public enum EKeyword
{
    /// <summary>
    /// For sub-folders for example (Also default value)
    /// </summary>
    None = 0,

    /// <summary>
    /// Typically set for Android packaging project.
    /// </summary>
    Package,

    /// <summary>
    /// Windows project (32 or 64 bit)
    /// </summary>
    Win32Proj,

    /// <summary>
    /// Android project
    /// </summary>
    Android
}


/// <summary>
/// Represents Visual studio project .xml model
/// </summary>
[DebuggerDisplay("{ProjectName}, {RelativePath}, {ProjectGuid}")]
public class Project
{
    /// <summary>
    /// Solution where project is included from. null if project loaded as standalone.
    /// </summary>
    [XmlIgnore]
    public Solution solution;

    /// <summary>
    /// true if it's folder (in solution), false if it's project. (default)
    /// </summary>
    public bool bIsFolder = false;

    /// <summary>
    /// true if it's Android packaging project
    /// </summary>
    public bool bIsPackagingProject = false;

    /// <summary>
    /// Don't generate project if defined as externalproject
    /// </summary>
    public bool bDefinedAsExternal = true;

    /// <summary>
    /// Made as a property so can be set over reflection.
    /// </summary>
    public String ProjectHostGuid
    {
        get
        {
            if (bIsFolder)
            {
                return "{2150E333-8FDC-42A3-9474-1A3956D46DE8}";
            }
            else
            {
                if (bIsPackagingProject)
                    return "{39E2626F-3545-4960-A6E8-258AD8476CE5}";

                return "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}";
            }
        }
        set
        {
            switch (value)
            {
                case "{2150E333-8FDC-42A3-9474-1A3956D46DE8}": bIsFolder = true; break;
                case "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}": bIsFolder = false; break;
                case "{39E2626F-3545-4960-A6E8-258AD8476CE5}": bIsFolder = false; bIsPackagingProject = true; break;
                default:
                    throw new Exception2("Invalid project host guid '" + value + "'");
            }
        }
    }

    /// <summary>
    /// "4.0" for vs2010/vs2012, "12.0" for vs2013, "14.0" for vs2015
    /// </summary>
    public String ToolsVersion;
    public EKeyword Keyword;

    public String getOsBase()
    {
        switch (Keyword)
        {
            case EKeyword.Android:
                return "android";
            case EKeyword.Package:
                return "package";
            default:
            case EKeyword.Win32Proj:
                if (Double.Parse(ToolsVersion, CultureInfo.InvariantCulture) <= 4.0)
                    return "vs2012";
                return "vs2015";
        }
    } //getOsBase


    /// <summary>
    /// Sets os base, returns false if not supported.
    /// </summary>
    public bool setOsBase(String osBase)
    {
        switch (osBase.ToLower())
        {
            case "package":
                bIsPackagingProject = true;
                ToolsVersion = "14.0";
                Keyword = EKeyword.Package;
                break;
            case "vs2010":
            case "vs2012":
                ToolsVersion = "4.0";
                Keyword = EKeyword.Win32Proj;
                break;
            case "vs2013":
                ToolsVersion = "12.0";
                Keyword = EKeyword.Win32Proj;
                break;
            case "vs2015":
                ToolsVersion = "14.0";
                Keyword = EKeyword.Win32Proj;
                break;
            case "android":
                ToolsVersion = "12.0";
                Keyword = EKeyword.Android;
                break;
            default:
                return false;
        }

        return true;
    } //setOsBase


    [XmlIgnore]
    public List<Project> nodes = new List<Project>();   // Child nodes (Empty folder also does not have any children)
    [XmlIgnore]
    public Project parent;                              // Points to folder which contains given project

    public string ProjectName;
    
    /// <summary>
    /// Sub-folder and filename of project to save. language defines project file extension
    /// </summary>
    public string RelativePath;
    public string language;                             // if null - RelativePath includes file extension, if non-null - "C++" or "C#" - defines project file extension.

    /// <summary>
    /// gets relative path based on programming language
    /// </summary>
    /// <returns></returns>
    public String getRelativePath()
    {
        if (RelativePath == null)
            throw new Exception2("Project '" + ProjectName + "' location was not specified");

        String path = RelativePath.Replace("/", "\\");

        if (bIsFolder)
            return path;

        if (Keyword == EKeyword.Package)
        {
            return path + ".androidproj";
        }
        
        if (language != null)
        {
            switch (language)
            {
                case "C++": return path + ".vcxproj";
                case "C#": return path + ".csproj";
            }
        }

        return path;
    } //getRelativePath


    public bool IsSubFolder()
    {
        return bIsFolder;
    }


    /// <summary>
    /// Same amount of configurations as in solution, this however lists project configurations, which correspond to solution configuration
    /// using same index.
    /// </summary>
    public List<String> slnConfigurations = new List<string>();

    /// <summary>
    /// List of supported configuration|platform permutations, like "Debug|Win32", "Debug|x64" and so on.
    /// </summary>
    public List<String> configurations = new List<string>();

    /// <summary>
    /// Gets list of supported configurations like 'Debug' / 'Release'
    /// </summary>
    public List<String> getConfigurationNames()
    {
        return configurations.Select(x => "\"" + x.Split('|')[0] + "\"").Distinct().ToList();
    }

    /// <summary>
    /// Gets list of supported platforms like 'Win32' / 'x64'
    /// </summary>
    public List<String> getPlatforms()
    {
        return configurations.Select(x => "\"" + x.Split('|')[1] + "\"").Distinct().ToList();
    }


    /// <summary>
    /// true or false whether to build project or not.
    /// </summary>
    public List<bool> slnBuildProject = new List<bool>();

    /// <summary>
    /// true to deploy project, false - not, null - invalid. List is null if not used at all.
    /// </summary>
    public List<bool?> slnDeployProject = null;

    /// <summary>
    /// Project guid, for example "{65787061-7400-0000-0000-000000000000}"
    /// </summary>
    public string ProjectGuid;

    /// <summary>
    /// per configuration list
    /// </summary>
    public List<Configuration> projectConfig = new List<Configuration>();

    /// <summary>
    /// Project dependent guids. Set to null if not used.
    /// </summary>
    public List<String> ProjectDependencies { get; set; }

    /// <summary>
    /// This array includes all items from ItemGroup, independently whether it's include file or file to compile, because
    /// visual studio is ordering them alphabetically - we keep same array to be able to sort files.
    /// </summary>
    public List<FileInfo> files = new List<FileInfo>();


    public string AsSlnString()
    {
        return "Project(\"" + ((bIsFolder) ? "Folder" : "Project") + "\") = \"" + ProjectName + "\", \"" + RelativePath + "\", \"" + ProjectGuid + "\"";
    }

    static String[] RegexExract(String pattern, String input)
    {
        Match m = Regex.Match(input, pattern);
        if (!m.Success)
            throw new Exception("Error: Parse failed (input string '" + input + "', regex: '" + pattern + "'");

        return m.Groups.Cast<Group>().Skip(1).Select(x => x.Value).ToArray();
    } //RegexExract


    /// <summary>
    /// Extracts configuration name in readable form.
    /// Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" => "Debug|x64"
    /// </summary>
    static String getConfiguration(XElement node)
    {
        String config = RegexExract("^'\\$\\(Configuration\\)\\|\\$\\(Platform\\)'=='(.*)'", node.Attribute("Condition").Value)[0];
        return config;
    }


    void confListInit<T>(ref List<T> list, T defT = default(T))
    {
        if( list == null )
            list = new List<T>(configurations.Count);

        while (list.Count < configurations.Count)
        {
            T t = defT;
            if (t == null)
                t = (T)Activator.CreateInstance(typeof(T));
            list.Add(t);
        }
    }


    /// <summary>
    /// Extracts compilation options for single cpp/cs file.
    /// </summary>
    /// <param name="clCompile">xml node from where to get</param>
    /// <param name="file2compile">compiler options to fill out</param>
    /// <param name="subField">Into which field to enter if non null</param>
    void ExtractCompileOptions(XElement clCompile, FileInfo file2compile, String subField)
    {
        foreach (XElement fileProps in clCompile.Elements())
        {
            String config = getConfiguration(fileProps);

            int iCfg = configurations.IndexOf(config);
            if (iCfg == -1)
                continue;           // Invalid configuration string specified.


            String localName = fileProps.Name.LocalName;
            Type type = typeof(FileConfigurationInfo);
            if (subField != null)
                type = type.GetField(subField).FieldType;       //==typeof(CustomBuildRule)

            FieldInfo fi = type.GetField(fileProps.Name.LocalName);
            if (fi == null)
            {
                if (Debugger.IsAttached) Debugger.Break();
                continue;
            }

            //
            // FileConfigurationInfo: PrecompiledHeader, PreprocessorDefinitions, AdditionalIncludeDirectories, ObjectFileName, XMLDocumentationFileName
            // CustomBuildRule: Command, Message, Outputs, AdditionalInputs
            //
            while (file2compile.fileConfig.Count < configurations.Count)
            {
                int i = file2compile.fileConfig.Count;
                // Add new configurations, use same precompiled header setting as project uses for given configuration.
                FileConfigurationInfo nfci = new FileConfigurationInfo() { PrecompiledHeader = projectConfig[i].PrecompiledHeader };
                file2compile.fileConfig.Add(nfci);

                if (subField != null)   
                    //file2compile.fileConfig[i].customBuildRule = new CustomBuildRule;
                    typeof(FileConfigurationInfo).GetField(subField).SetValue(nfci, Activator.CreateInstance(type));
            } //while

            FileConfigurationInfo fci = file2compile.fileConfig[iCfg];
            Object o2set;

            if (subField == null)
                o2set = fci;
            else
                o2set = typeof(FileConfigurationInfo).GetField(subField).GetValue(fci);     //fci.customBuildRule

            object oValue;

            if (fi.FieldType.IsEnum)
                oValue = Enum.Parse(fi.FieldType, fileProps.Value);
            else
                oValue = Convert.ChangeType(fileProps.Value, fi.FieldType);

            fi.SetValue(o2set, oValue);
        } //foreach
    } //ExtractCompileOptions

    static void CopyField(object o2set, String field, XElement node)
    {
        FieldInfo fi = o2set.GetType().GetField(field);
        Object oValue = node.Element(node.Document.Root.Name.Namespace + field)?.Value;

        if (fi.FieldType == typeof(EKeyword))
        {
            if (oValue == null)
                oValue = EKeyword.Package;
            else
                oValue = Enum.Parse(typeof(EKeyword), (String)oValue);
        }

        fi.SetValue(o2set, oValue);
    }

    void extractGeneralCompileOptions(XElement node)
    {
        String config = getConfiguration(node);

        int iCfg = configurations.IndexOf(config);

        if (iCfg == -1)
            return;

        Configuration cfg = projectConfig[iCfg];

        List<XElement> nodes = node.Elements().ToList();

        //  Explode sub nodes if we have anything extra to scan. (Comes from ItemDefinitionGroup)
        for (int i = 0; i < nodes.Count; i++)
        {
            String nodeName = nodes[i].Name.LocalName;
            // Nodes can be exploded into same scan loop as long as key do not overlap (e.g. compile options versus link options).
            if (nodeName == "ClCompile" || nodeName == "Link" || nodeName == "AntPackage")    // These nodes are located in ItemDefinitionGroup, we simply expand sub children.
            {
                nodes.AddRange(nodes[i].Elements());
                nodes.RemoveAt(i);
                i--;
            }
        } //for

        foreach (XElement cfgNode in nodes)
        {
            String fieldName = cfgNode.Name.LocalName;

            if (fieldName == "LibraryDependencies")
                fieldName = "AdditionalDependencies";

            FieldInfo fi = typeof(Configuration).GetField(fieldName);
            if (fi == null)
                continue;

            if (fi.FieldType.IsEnum)
            {
                if (fi.FieldType.GetCustomAttribute<DescriptionAttribute>() == null )
                {
                    fi.SetValue(cfg, Enum.Parse(fi.FieldType, cfgNode.Value));
                }
                else
                {
                    // Extract from Description attributes their values and map corresponding enumeration.
                    int value = fi.FieldType.GetEnumNames().Select(x => fi.FieldType.GetMember(x)[0].GetCustomAttribute<DescriptionAttribute>().Description).ToList().IndexOf(cfgNode.Value);
                    if (value == -1)
                        new Exception2("Invalid / not supported value '" + cfgNode.Value + "'");
                    fi.SetValue(cfg, Enum.Parse(fi.FieldType, fi.FieldType.GetEnumNames()[value]));
                }

                if (fieldName == "ConfigurationType")
                    ((Configuration)cfg).ConfigurationTypeUpdated();
            }
            else
            {
                fi.SetValue(cfg, Convert.ChangeType(cfgNode.Value, fi.FieldType));
            }
        } //foreach
    } //extractGeneralCompileOptions



    /// <summary>
    /// Loads project. If project exists in solution, it's loaded in same instance.
    /// </summary>
    /// <param name="solution">Solution if any exists, null if not available.</param>
    static public Project LoadProject(Solution solution, String path, Project project = null)
    {
        if (path == null)
            path = Path.Combine(Path.GetDirectoryName(solution.path) , project.RelativePath);

        if (project == null)
            project = new Project() { solution = solution };

        if (!File.Exists(path))
            return null;

        XDocument p = XDocument.Load(path);

        project.ToolsVersion = p.Root.Attribute("ToolsVersion").Value;

        foreach (XElement node in p.Root.Elements())
        {
            String lname = node.Name.LocalName;

            switch (lname)
            {
                case "ItemGroup":
                    // ProjectConfiguration has Configuration & Platform sub nodes, but they cannot be reconfigured to anything else then this attribute.
                    if (node.Attribute("Label")?.Value == "ProjectConfigurations")
                    {
                        project.configurations = node.Elements().Select(x => x.Attribute("Include").Value).ToList();
                        project.configurations.ForEach(x => project.projectConfig.Add(new Configuration()));
                    }
                    else
                    {
                        //
                        // .h / .cpp / custom build files are picked up here.
                        //
                        foreach (XElement igNode in node.Elements())
                        {
                            FileInfo f = new FileInfo();
                            f.includeType = (IncludeType)Enum.Parse(typeof(IncludeType), igNode.Name.LocalName);
                            f.relativePath = igNode.Attribute("Include").Value;

                            if (f.includeType == IncludeType.ClCompile || f.includeType == IncludeType.CustomBuild)
                                project.ExtractCompileOptions(igNode, f, (f.includeType == IncludeType.CustomBuild) ? "customBuildRule" : null );

                            if (f.includeType == IncludeType.ProjectReference)
                                f.Project = igNode.Elements().Where(x => x.Name.LocalName == "Project").FirstOrDefault()?.Value;

                            project.files.Add(f);
                        } //for
                    }
                    break;

                case "PropertyGroup":
                    {
                        String label = node.Attribute("Label")?.Value;

                        switch (label)
                        {
                            case "Globals":
                                foreach (String field in new String[] { "ProjectGuid", "Keyword" /*, "RootNamespace"*/ })
                                    CopyField(project, field, node);
                                break;

                            case null:                  // Non tagged node contains rest of configurations like 'LinkIncremental', 'OutDir', 'IntDir', 'TargetName', 'TargetExt'
                                
                                if (node.Attribute("Condition") == null)
                                    // Android packaging project can contain such empty nodes. "<PropertyGroup />"
                                    continue;

                                project.extractGeneralCompileOptions(node);
                                break;

                            case "Configuration":
                                project.extractGeneralCompileOptions(node);
                                break;
                            case "UserMacros":
                                // What is it - does needs to be supported ?
                                break;

                            default:
                                if (Debugger.IsAttached) Debugger.Break();
                                break;
                        } //switch
                    }
                    break;

                case "Import": break;           // Skip for now.
                case "ImportGroup": break;      // Skip for now.
                case "ItemDefinitionGroup":
                    project.extractGeneralCompileOptions(node);
                    break;

                default:
                    if (Debugger.IsAttached) Debugger.Break();
                    break;
            } //switch
        } //foreach

        return project;
    } //LoadProject

    static String condition( String confName )
    {
        return "Condition=\"'$(Configuration)|$(Platform)'=='" + confName + "'\"";
    }

    StringBuilder o;    // Stream where we serialize project.

    /// <summary>
    /// Dumps file or project specific configuration.
    /// </summary>
    /// <param name="conf">Configuration to dump</param>
    /// <param name="confName">Configuration name, null if project wise</param>
    /// <param name="projectConf">Project configuration, null if conf is file specific configuration</param>
    void DumpConfiguration(FileConfigurationInfo conf, String confName = null, Configuration projectConf = null )
    {
        String sCond = "";
        if (confName != null)
            sCond = " " + condition(confName);

        if (conf.PreprocessorDefinitions.Length != 0)
        {
            String defines = conf.PreprocessorDefinitions;
            if (defines.Length != 0) defines += ";";
            defines += "%(PreprocessorDefinitions)";

            o.AppendLine("      <PreprocessorDefinitions" + sCond + ">" + defines + "</PreprocessorDefinitions>");
        }

        if( conf.DebugInformationFormat != EDebugInformationFormat.ProgramDatabase )
            o.AppendLine("      <DebugInformationFormat" + sCond + ">" + conf.DebugInformationFormat.ToString() + "</DebugInformationFormat>");

        if (conf.AdditionalIncludeDirectories.Length != 0 )
            o.AppendLine("      <AdditionalIncludeDirectories" + sCond + ">" + conf.AdditionalIncludeDirectories + "</AdditionalIncludeDirectories>");

        if (projectConf != null && projectConf.PrecompiledHeader != conf.PrecompiledHeader)
            o.AppendLine("      <PrecompiledHeader" + sCond + ">" + conf.PrecompiledHeader + "</PrecompiledHeader>");
    } //DumpConfiguration


    /// <summary>
    /// Resorts configuration list in some particular order.
    /// </summary>
    /// <param name="configurations">Configuration to sort</param>
    /// <param name="bX3264hasPriority">x86 / x64 platforms have priority.</param>
    /// <param name="b64HasPriority">64 bit configurations have priority. null if not use this sort criteria.</param>
    /// <param name="bCompareConfigNameFirst">true if compare config name first</param>
    /// <returns></returns>
    static public List<String> getSortedConfigurations(List<String> configurations, bool bX3264hasPriority, bool? b64HasPriority = true, bool bCompareConfigNameFirst = false)
    {
        List<String> configurationsSorted = configurations;
        int xPriority = bX3264hasPriority ? 1 : -1;
        int xa64Priority = 1;
        
        if(b64HasPriority.HasValue) 
            xa64Priority = b64HasPriority.Value ? 1 : -1;
        
            configurationsSorted.Sort(delegate (String c1, String c2)
        {
            String[] cp1 = c1.Split('|');
            String[] cp2 = c2.Split('|');
            String p1 = cp1[1].ToLower();
            String p2 = cp2[1].ToLower();

            if (bCompareConfigNameFirst)
            {
                int cr2 = cp1[0].CompareTo(cp2[0]);
                if (cr2 != 0)
                    return cr2;
            }

            if (p1.StartsWith("x") != p2.StartsWith("x"))       // Give x86 & x64 priority over ARM based names.
                return p1.StartsWith("x") ? -xPriority : xPriority;

            if (b64HasPriority.HasValue)
            {
                if (p1.Contains("64") != p2.Contains("64"))         // 64-bit named configurations have priority.
                    return p1.Contains("64") ? -xa64Priority : xa64Priority;
            }

            int cr = p1.CompareTo(p2);
            if (cr != 0)
                return cr;

            return cp1[0].CompareTo(cp2[0]);
        }
        );

        return configurationsSorted;
    }
    
    List<String> getSortedConfigurations(bool bX3264hasPriority)
    {
        return Project.getSortedConfigurations(configurations, bX3264hasPriority);
    }


    IncludeType simplifyForGroupReopen(IncludeType inctype)
    {
        switch (inctype)
        {
            default:
                return inctype;

            case IncludeType.ProjectReference:
                return inctype;     // Must be separated from rest of xml stuff

            case IncludeType.AndroidManifest:
            case IncludeType.Content:
            case IncludeType.AntBuildXml:
            case IncludeType.AntProjectPropertiesFile:
                // Android tags does not require ItemGroup reopen, just return one of android types.
                return IncludeType.Content;
        }
    }



    /// <summary>
    /// Saves project if necessary.
    /// </summary>
    public void SaveProject()
    {
        //
        // We serialize here using string append, so we can easily compare with Visual studio projects with your favorite comaprison tool.
        //
        if (String.IsNullOrEmpty(ProjectGuid))
        {
            SolutionProjectBuilder.externalproject(null);
            SolutionProjectBuilder.m_project = this;
            SolutionProjectBuilder.uuid(ProjectName);
            SolutionProjectBuilder.m_project = null;
        }

        String projectPath;

        if (solution == null)
            projectPath = SolutionProjectBuilder.m_workPath;
        else
            projectPath = Path.GetDirectoryName(solution.path);
        projectPath = Path.Combine(projectPath, getRelativePath());

        o = new StringBuilder();
        o.AppendLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        o.AppendLine("<Project DefaultTargets=\"Build\" ToolsVersion=\"" + ToolsVersion + "\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">");
        o.AppendLine("  <ItemGroup Label=\"ProjectConfigurations\">");

        //
        // Dump configuration list
        //
        foreach (String config in configurations)
        {
            String[] confPlatfom = config.Split('|');
            o.AppendLine("    <ProjectConfiguration Include=\"" + config + "\">");
            o.AppendLine("      <Configuration>" + confPlatfom[0] + "</Configuration>");
            o.AppendLine("      <Platform>" + confPlatfom[1] + "</Platform>");
            o.AppendLine("    </ProjectConfiguration>");
        }
        o.AppendLine("  </ItemGroup>");

        o.AppendLine("  <PropertyGroup Label=\"Globals\">");
        
        bool bIsPackagingProject = Keyword == EKeyword.Package;
        
        if(!bIsPackagingProject)
            o.AppendLine("    <ProjectGuid>" + ProjectGuid + "</ProjectGuid>");

        //
        // Copied from premake5: VS 2013 adds the <IgnoreWarnCompileDuplicatedFilename> to get rid
        // of spurious warnings when the same filename is present in different
        // configurations.
        //
        if(!bIsPackagingProject)
            o.AppendLine("    <IgnoreWarnCompileDuplicatedFilename>true</IgnoreWarnCompileDuplicatedFilename>");
        
        if( Keyword != EKeyword.Package )
            o.AppendLine("    <Keyword>" + Keyword + "</Keyword>");

        String rootNamespace = ProjectName;
        if (rootNamespace.IndexOf('.') != -1)
            rootNamespace = rootNamespace.Substring(0, rootNamespace.IndexOf('.'));

        o.AppendLine("    <RootNamespace>" + rootNamespace + "</RootNamespace>");

        bool bIsAndroidProject = Keyword == EKeyword.Android;
        if (bIsAndroidProject)
            o.AppendLine("    <DefaultLanguage>en-US</DefaultLanguage>");

        if (bIsAndroidProject || bIsPackagingProject)
            o.AppendLine("    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>");
        
        if (bIsPackagingProject)
            o.AppendLine("    <ProjectVersion>1.0</ProjectVersion>");

        if (bIsPackagingProject)
            o.AppendLine("    <ProjectGuid>" + ProjectGuid + "</ProjectGuid>");

        if (bIsAndroidProject)
            o.AppendLine("    <ApplicationType>Android</ApplicationType>");
        
        if (bIsAndroidProject)
            o.AppendLine("    <ApplicationTypeRevision>2.0</ApplicationTypeRevision>");

        o.AppendLine("  </PropertyGroup>");

        // Some mysterious xml tag.
        String propsPath = "$(VCTargetsPath)\\Microsoft.Cpp";

        if (Keyword == EKeyword.Package)
            propsPath = "$(AndroidTargetsPath)\\Android";

        o.AppendLine("  <Import Project=\""+ propsPath + ".Default.props\" />");

        //
        // Dump general information.
        //
        foreach ( String confName in getSortedConfigurations( Keyword == EKeyword.Android ))
        {
            int iConf = configurations.IndexOf(confName);
            Configuration conf = projectConfig[iConf];

            o.AppendLine("  <PropertyGroup " + condition(confName) + " Label=\"Configuration\">");

            if (bIsPackagingProject)
            {
                o.AppendLine("    <UseDebugLibraries>" + conf.UseDebugLibraries.ToString().ToLower() + "</UseDebugLibraries>");
                o.AppendLine("    <ConfigurationType>Application</ConfigurationType>"); // Why this line is needed anyway?
                if (conf.AndroidAPILevel != "android-19" )
                    o.AppendLine("    <AndroidAPILevel>" + conf.AndroidAPILevel + "</AndroidAPILevel>");
            }
            else {
                o.AppendLine("    <ConfigurationType>" + conf.ConfigurationType.ToString() + "</ConfigurationType>");
                o.AppendLine("    <UseDebugLibraries>" + conf.UseDebugLibraries.ToString().ToLower() + "</UseDebugLibraries>");
            }

            if (!bIsPackagingProject)
            {
                String pts = conf.PlatformToolset;
                if (pts == null) pts = conf.getPlatformToolsetDefault(this);
                o.AppendLine("    <PlatformToolset>" + pts + "</PlatformToolset>");

                if (Keyword == EKeyword.Android && conf.AndroidAPILevel != "android-19")
                    o.AppendLine("    <AndroidAPILevel>" + conf.AndroidAPILevel + "</AndroidAPILevel>");
            }

            if (conf.WholeProgramOptimization != EWholeProgramOptimization.NoWholeProgramOptimization)
            {
                String value = typeof(EWholeProgramOptimization).GetMember(conf.WholeProgramOptimization.ToString())[0].GetCustomAttribute<DescriptionAttribute>().Description;
                o.AppendLine("    <WholeProgramOptimization>" + value + "</WholeProgramOptimization>");
            }
            if( Keyword == EKeyword.Win32Proj )
                o.AppendLine("    <CharacterSet>" + conf.CharacterSet.ToString() + "</CharacterSet>");
            o.AppendLine("  </PropertyGroup>");
        } //for

        o.AppendLine("  <Import Project=\"" + propsPath + ".props\" />");

        if (Keyword == EKeyword.Package)
        {
            o.AppendLine("  <ImportGroup Label=\"ExtensionSettings\" />");
        }
        else
        {
            o.AppendLine("  <ImportGroup Label=\"ExtensionSettings\">");
            o.AppendLine("  </ImportGroup>");
        }

        if (Keyword == EKeyword.Android)
        {
            o.AppendLine("  <ImportGroup Label=\"Shared\">");
            o.AppendLine("  </ImportGroup>");
        }
        else if (Keyword == EKeyword.Package)
        { 
            o.AppendLine("  <ImportGroup Label=\"Shared\" />");
        }

        if( !bIsPackagingProject )
            foreach (String confName in getSortedConfigurations(true))
            { 
                o.AppendLine("  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='" + confName + "'\">");
                o.AppendLine("    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />");
                o.AppendLine("  </ImportGroup>");
            } //foreach

        //
        // Dump compiler and linker options.
        //
        o.AppendLine("  <PropertyGroup Label=\"UserMacros\" />");

        if (bIsPackagingProject)
            o.AppendLine("  <PropertyGroup />");

        if ( !bIsPackagingProject )
            foreach (String confName in getSortedConfigurations(false))
            {
                int iConf = configurations.IndexOf(confName);
                Configuration conf = projectConfig[iConf];

                bool bAppendLinkIncremental = Keyword != EKeyword.Android;
                bool bAppendOutDir = conf.OutDir != null && conf.OutDir != conf.getOutDirDefault(this);
                bool bAppendIntDir = conf.IntDir != null && conf.IntDir != conf.getOutDirDefault(this);
                bool bAppendTargetName = conf.TargetName != null && conf.TargetName != conf.getTargetNameDefault(this);
                bool bAppendTargetExt = conf.TargetExt != null;

                // Empty node.
                if (!(bAppendLinkIncremental || bAppendOutDir || bAppendIntDir || bAppendTargetName || bAppendTargetExt))
                { 
                    o.AppendLine("  <PropertyGroup " + condition(confName) + " />");
                    continue;
                }

                o.AppendLine("  <PropertyGroup " + condition(confName) + ">");
                
                if (bAppendLinkIncremental)
                    o.AppendLine("    <LinkIncremental>" + conf.LinkIncremental.ToString().ToLower() + "</LinkIncremental>");
            
                if(bAppendOutDir)
                    o.AppendLine("    <OutDir>" + conf.OutDir + "</OutDir>");

                if(bAppendIntDir) 
                    o.AppendLine("    <IntDir>" + conf.IntDir + "</IntDir>");
            
                if (bAppendTargetName) 
                    o.AppendLine("    <TargetName>" + conf.TargetName + "</TargetName>");
            
                if(bAppendTargetExt)
                    o.AppendLine("    <TargetExt>" + conf.TargetExt + "</TargetExt>");

                o.AppendLine("  </PropertyGroup>");
            } //for

        for (int iConf = 0; iConf < configurations.Count; iConf++)
        {
            String confName = configurations[iConf];
            Configuration conf = projectConfig[iConf];
            o.AppendLine("  <ItemDefinitionGroup " + condition(confName) + ">");

            if (bIsPackagingProject)
            {
                o.AppendLine("    <AntPackage>");
                o.AppendLine("      <AndroidAppLibName>$(RootNamespace)</AndroidAppLibName>");
                o.AppendLine("    </AntPackage>");
                o.AppendLine("  </ItemDefinitionGroup>");
                continue;
            }

            o.AppendLine("    <ClCompile>");
            o.AppendLine("      <PrecompiledHeader>" + conf.PrecompiledHeader.ToString() + "</PrecompiledHeader>");
            
            // No need to specify if it's default header file.
            if (conf.PrecompiledHeader == EPrecompiledHeaderUse.Use && conf.PrecompiledHeaderFile != "stdafx.h")
                o.AppendLine("      <PrecompiledHeaderFile>" + conf.PrecompiledHeaderFile + "</PrecompiledHeaderFile>");

            if( Keyword == EKeyword.Android )
                o.AppendLine("      <CompileAs>CompileAsCpp</CompileAs>");

            // No need to specify as it's Visual studio default.
            if (conf.WarningLevel != EWarningLevel.Level1 )
                o.AppendLine("      <WarningLevel>" + conf.WarningLevel + "</WarningLevel>");
            
            o.AppendLine("      <Optimization>" + conf.Optimization + "</Optimization>");
            
            if(conf.FunctionLevelLinking)   //premake5 is not generating those, I guess disabled if it's value is false.
                o.AppendLine("      <FunctionLevelLinking>true</FunctionLevelLinking>");
            if(conf.IntrinsicFunctions && Keyword != EKeyword.Android )
                o.AppendLine("      <IntrinsicFunctions>true</IntrinsicFunctions>");
            if(conf.EnableCOMDATFolding)
                o.AppendLine("      <EnableCOMDATFolding>true</EnableCOMDATFolding>");
            if (conf.OptimizeReferences)
                o.AppendLine("      <OptimizeReferences>true</OptimizeReferences>");

            DumpConfiguration(conf);

            o.AppendLine("    </ClCompile>");

            o.AppendLine("    <Link>");
            
            if( Keyword != EKeyword.Android )
                o.AppendLine("      <SubSystem>" + conf.SubSystem + "</SubSystem>");

            if (Keyword != EKeyword.Android)
            {
                String v = "";
                switch (conf.GenerateDebugInformation)
                {
                    default:
                    case EGenerateDebugInformation.No: v = "false"; break;
                    case EGenerateDebugInformation.OptimizeForDebugging: v = "true"; break;
                    case EGenerateDebugInformation.OptimizeForFasterLinking: v = "DebugFastLink"; break;
                }
                o.AppendLine("      <GenerateDebugInformation>" + v + "</GenerateDebugInformation>");
            } //if

            // Link libraries.
            String links = conf.AdditionalDependencies;

            if (conf.LibraryDependencies.Length != 0)
            {
                if (links.Length != 0) links += ";";
                links += conf.LibraryDependencies;
            }

            if (links.Length != 0)
            {
                if (Keyword == EKeyword.Win32Proj)
                {
                    o.AppendLine("      <AdditionalDependencies>" + links + ";%(AdditionalDependencies)</AdditionalDependencies>");
                }
                else
                {
                    o.AppendLine("      <LibraryDependencies>%(LibraryDependencies);" + links + ";</LibraryDependencies>");
                    //o.AppendLine("      <AdditionalDependencies>");
                    //o.AppendLine("      </AdditionalDependencies>");
                }
            }

            if (conf.AdditionalLibraryDirectories.Length != 0)
                o.AppendLine("      <AdditionalLibraryDirectories>" + conf.AdditionalLibraryDirectories + "</AdditionalLibraryDirectories>");
            
            // OutputFile ?
            o.AppendLine("    </Link>");
            o.AppendLine("  </ItemDefinitionGroup>");
        } //for


        IncludeType inctype = IncludeType.Invalid;
        bool bItemGroupOpened = false;
        //
        // Dump files array
        //
        foreach (FileInfo fi in files)
        {
            bool bHasCustomBuildStep = fi.fileConfig.Where(x => x.customBuildRule != null).FirstOrDefault() != null;

            if (bHasCustomBuildStep)
                fi.includeType = IncludeType.CustomBuild;

            if (simplifyForGroupReopen(inctype) != simplifyForGroupReopen(fi.includeType))
            { 
                if( bItemGroupOpened )
                    o.AppendLine("  </ItemGroup>");

                o.AppendLine("  <ItemGroup>");
                bItemGroupOpened = true;
                inctype = fi.includeType;
            } //if

            o.Append("    <" + fi.includeType + " Include=\"" + fi.relativePath.Replace("/", "\\") + "\"");

            if (fi.includeType == IncludeType.ProjectReference)
            { 
                o.AppendLine(">");
                o.AppendLine("      <Project>" + fi.Project + "</Project>");
                o.AppendLine("    </ProjectReference>");
                continue;
            }

            if (fi.includeType == IncludeType.CustomBuild)
            { 
                o.AppendLine(">");

                foreach (String confName in getSortedConfigurations(false))
                {
                    int iConf = configurations.IndexOf(confName);
                    CustomBuildRule cbr = fi.fileConfig[iConf].customBuildRule;

                    if (cbr == null)
                        continue;

                    o.AppendLine("      <Command " + condition(confName) + ">" + cbr.Command + "</Command>");
                    o.AppendLine("      <Outputs " + condition(confName) + ">" + cbr.Outputs + "</Outputs>");
                    if(cbr.Message != "Performing Custom Build Tools")
                        o.AppendLine("      <Message " + condition(confName) + ">" + cbr.Message + "</Message>");
                } //foreach

                o.AppendLine("    </CustomBuild>");
                continue;
            }

            if (fi.fileConfig.Count == 0)
            {
                o.AppendLine(" />");
            }
            else
            {
                o.AppendLine(">");

                // We have file specific configuration options
                for (int iConf = 0; iConf < configurations.Count; iConf++)
                {
                    String confName = configurations[iConf];
                    FileConfigurationInfo conf = fi.fileConfig[iConf];
                    DumpConfiguration(conf, confName, projectConfig[iConf]);
                }
                o.AppendLine("    </" + fi.includeType + ">");
            } //if-else
        } //for

        if (bItemGroupOpened)
            o.AppendLine("  </ItemGroup>");

        
        o.AppendLine("  <Import Project=\""+ propsPath + ".targets\" />");

        if (bIsPackagingProject)
        {
            o.AppendLine("  <ImportGroup Label=\"ExtensionTargets\" />");
        }
        else { 
            o.AppendLine("  <ImportGroup Label=\"ExtensionTargets\">");
            o.AppendLine("  </ImportGroup>");
        }
        o.AppendLine("</Project>");

        //
        // Write project itself.
        //
        String currentPrj = "";
        Console.Write("Updating project '" + projectPath + "' ... ");
        if (File.Exists(projectPath)) currentPrj = File.ReadAllText(projectPath);

        String newPrj = o.ToString();

        if( Keyword == EKeyword.Win32Proj )     // Android & None projects have windows linefeeds.
            newPrj = newPrj.Replace("\r\n", "\n");

        //
        // Save only if needed.
        //
        if (currentPrj == newPrj)
        {
            Console.WriteLine("up-to-date.");
        }
        else
        {
            File.WriteAllText(projectPath, newPrj, Encoding.UTF8);
            Console.WriteLine("ok.");
        } //if-else

    } //SaveProject
} //Project

